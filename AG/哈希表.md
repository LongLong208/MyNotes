<!-- @import "_pre.css" -->


## 哈希表


`哈希表` 是一种使用 哈希函数 组织数据，以支持快速插入和搜索的数据结构

有两种不同类型的哈希表：哈希集合 和 哈希映射

`哈希集合` 是 `集合` 的实现方式之一，用于存储 非重复值
`哈希映射` 是 `映射` 的实现之一，用于存储 (key, value) 键值对

<br>

### 哈希表的原理

哈希表（又称散列表）的原理为：借助 哈希函数，将键映射到存储桶地址

- 首先开辟一定长度的，具有连续物理地址的桶数组；

- 当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；

- 当我们想要搜索一个键时，哈希表将使用哈希函数来找到对应的桶，并在该桶中进行搜索。

<br>

#### 负载因子

又称装填因子，是衡量哈希表装满程度的参数

负载因子 = 实际使用桶的个数 / 桶的总数

比较合理的负载因子是 **`0.7`**

<br>

### 哈希表的设计及问题

#### 哈希函数

哈希函数是哈希表中最重要的组件，用于将键映射到特定的桶

一个好的哈希函数，应当具备以下几个特点：

1. 哈希函数的键与桶关系具有确定性，即桶地址只由 `key` 决定；理想情况下，完美的哈希函数是键和桶的一对一映射
2. 哈希函数不应太过复杂，要保证能快速定位桶
3. 哈希函数的映射结果应具有均匀性

<br>

#### 冲突

经过映射之后，不同的数据会不可避免地分配到同一个桶中，这时便产生了冲突

这里介绍几种解决冲突的办法

##### 开放寻址法

哈希函数 `h(key, times)`

先用哈希函数探测一次，如果该位置满了，则用第二个哈希函数勘探第二次，如此循环，直至到达一个空位置

1. 线性勘探法
   \(h(k,i)=(h(k,0)+i)\mod m\)
   k : key
   i : 冲突次数

2. 二次哈希
   \(h(k,i)=(h_1(k)+i∗h_2(k))\mod m\)
   通常选择 \(m=2^r\) 和 返回奇数的 \(h_2(k)\)

<br>

##### 链地址法（拉链法）

```ditaa {cmd args=["-s 1.5","-E"] align=center class=ditaa}
+--------+
| record |
+--------+
+--------+     +----+     +----+     +----+
+--------+     | 46 |     | 56 |     | 52 |
|   icCEF+---->|cFDD+---->|cFDD+---->|cFDD|
+--------+     +----+     +----+     +----+
+--------+                           
+--------+
```

<br>

##### 公共溢出区法

公共溢出区法就是建立另一个哈希表 `dict_overflow` 作为公共溢出区，当发成冲突时则将该键保存在该哈希表中

```ditaa {cmd args=["-s 1.5","-E"] align=center class=ditaa}
                key % 8
+----+----+----+----+----+----+----+----+
| 8  | 9  | 34 |    | 4  | 21 |    |    |
|cCEF|cFDD|cCEF|cEEE|cFDD|cCEF|cEEE|cEEE|
+----++---+----+----++---+----+----+----+
  0   |1    2    3   |4    5    6    7
  /---/              |
  |    /-------------/
  |    |
  v    v
+----+----+----+----+----+
| 17 | 12 |    |    |    |dict_overflow
|cFDD|cFDD|cEEE|cEEE|cEEE|
+----+----+----+----+----+
```

<br>
<br>
<br>

---
